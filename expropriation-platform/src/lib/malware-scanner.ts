import * as fs from 'fs/promises';
import * as crypto from 'crypto';
import * as path from 'path';

// Malware scan result
export interface MalwareScanResult {
  isClean: boolean;
  threats: MalwareThreat[];
  scanTime: number;
  confidence: number;
  warnings: string[];
  metadata: {
    fileSize: number;
    fileHash: string;
    scannedAt: string;
    scannerVersion: string;
  };
}

export interface MalwareThreat {
  type: 'virus' | 'trojan' | 'worm' | 'spyware' | 'adware' | 'suspicious' | 'policy_violation';
  name: string;
  description: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  confidence: number;
  location?: string; // For archive files
}

// Known malware signatures (simplified - in production use a real antivirus engine)
export const MALWARE_SIGNATURES = [
  // EICAR test signature
  {
    pattern: Buffer.from('X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*'),
    name: 'EICAR-Test-File',
    type: 'test' as const,
    description: 'EICAR Antivirus Test File',
  },

  // Suspicious patterns
  {
    pattern: Buffer.from([0x4D, 0x5A]), // MZ header (PE executable)
    name: 'PE-Executable',
    type: 'suspicious' as const,
    description: 'Windows PE executable detected',
  },

  {
    pattern: Buffer.from([0x7F, 0x45, 0x4C, 0x46]), // ELF header
    name: 'ELF-Executable',
    type: 'suspicious' as const,
    description: 'Linux ELF executable detected',
  },

  {
    pattern: Buffer.from([0xCA, 0xFE, 0xBA, 0xBE]), // Java class file
    name: 'Java-Class',
    type: 'suspicious' as const,
    description: 'Java class file detected',
  },
];

// Suspicious string patterns for text files
export const SUSPICIOUS_STRING_PATTERNS = [
  {
    pattern: /eval\s*\(/gi,
    name: 'Eval-Function',
    type: 'suspicious' as const,
    description: 'Dangerous eval() function usage',
    severity: 'medium' as const,
  },

  {
    pattern: /exec\s*\(/gi,
    name: 'Exec-Function',
    type: 'suspicious' as const,
    description: 'Dangerous exec() function usage',
    severity: 'medium' as const,
  },

  {
    pattern: /system\s*\(/gi,
    name: 'System-Function',
    type: 'suspicious' as const,
    description: 'Dangerous system() function usage',
    severity: 'medium' as const,
  },

  {
    pattern: /powershell/i,
    name: 'PowerShell',
    type: 'suspicious' as const,
    description: 'PowerShell command detected',
    severity: 'high' as const,
  },

  {
    pattern: /cmd\.exe/i,
    name: 'CMD-Exec',
    type: 'suspicious' as const,
    description: 'Command prompt execution detected',
    severity: 'high' as const,
  },

  {
    pattern: /bash\s+-/gi,
    name: 'Bash-Exec',
    type: 'suspicious' as const,
    description: 'Bash shell execution detected',
    severity: 'high' as const,
  },

  {
    pattern: /https?:\/\/[^\s]*\.(exe|bat|scr|com|pif)/gi,
    name: 'Suspicious-URL',
    type: 'suspicious' as const,
    description: 'URL pointing to executable file',
    severity: 'high' as const,
  },

  {
    pattern: /javascript:/gi,
    name: 'JavaScript-Protocol',
    type: 'suspicious' as const,
    description: 'JavaScript protocol usage',
    severity: 'medium' as const,
  },

  {
    pattern: /data:text\/html/gi,
    name: 'Data-HTML',
    type: 'suspicious' as const,
    description: 'HTML data URI detected',
    severity: 'medium' as const,
  },
];

// File entropy analysis for detecting encrypted/packed malware
export function calculateFileEntropy(buffer: Buffer): number {
  const frequency = new Array(256).fill(0);

  // Count byte frequencies
  for (const byte of buffer) {
    frequency[byte]++;
  }

  // Calculate Shannon entropy
  let entropy = 0;
  const length = buffer.length;

  for (const count of frequency) {
    if (count > 0) {
      const probability = count / length;
      entropy -= probability * Math.log2(probability);
    }
  }

  return entropy;
}

// Scan file buffer for known malware signatures
function scanForSignatures(buffer: Buffer): MalwareThreat[] {
  const threats: MalwareThreat[] = [];

  for (const signature of MALWARE_SIGNATURES) {
    // Check if signature pattern exists in file
    const patternLength = signature.pattern.length;

    for (let i = 0; i <= buffer.length - patternLength; i++) {
      const fileSlice = buffer.slice(i, i + patternLength);

      if (fileSlice.equals(signature.pattern)) {
        threats.push({
          type: signature.type === 'test' ? 'suspicious' : 'virus',
          name: signature.name,
          description: signature.description,
          severity: signature.type === 'test' ? 'low' : 'critical',
          confidence: 0.95,
        });
        break; // Found match, move to next signature
      }
    }
  }

  return threats;
}

// Scan text content for suspicious patterns
function scanForSuspiciousStrings(content: string): MalwareThreat[] {
  const threats: MalwareThreat[] = [];

  for (const pattern of SUSPICIOUS_STRING_PATTERNS) {
    const matches = content.match(pattern.pattern);
    if (matches) {
      threats.push({
        type: 'suspicious',
        name: pattern.name,
        description: pattern.description,
        severity: pattern.severity,
        confidence: 0.7,
      });
    }
  }

  return threats;
}

// Analyze file entropy to detect packing/encryption
function analyzeFileEntropy(buffer: Buffer): MalwareThreat[] {
  const threats: MalwareThreat[] = [];
  const entropy = calculateFileEntropy(buffer);

  // High entropy (>7.5) may indicate packed or encrypted malware
  if (entropy > 7.5) {
    threats.push({
      type: 'suspicious',
      name: 'High-Entropy',
      description: `File has high entropy (${entropy.toFixed(2)}), possibly packed or encrypted`,
      severity: entropy > 8.0 ? 'high' : 'medium',
      confidence: Math.min(0.8, (entropy - 7.0) * 0.4),
    });
  }

  return threats;
}

// Scan for suspicious file metadata
function scanFileMetadata(fileName: string, fileSize: number): MalwareThreat[] {
  const threats: MalwareThreat[] = [];

  // Check for suspicious file extensions
  const suspiciousExtensions = ['.scr', '.pif', '.com', '.bat', '.cmd', '.js', '.jar', '.vbs', '.ps1'];
  const ext = path.extname(fileName).toLowerCase();

  if (suspiciousExtensions.includes(ext)) {
    threats.push({
      type: 'suspicious',
      name: 'Suspicious-Extension',
      description: `File has suspicious extension: ${ext}`,
      severity: 'medium',
      confidence: 0.8,
    });
  }

  // Check for suspicious file names
  const suspiciousNames = ['setup', 'install', 'crack', 'keygen', 'patch', 'loader', 'dropper'];
  const baseName = path.basename(fileName, ext).toLowerCase();

  for (const name of suspiciousNames) {
    if (baseName.includes(name)) {
      threats.push({
        type: 'suspicious',
        name: 'Suspicious-Filename',
        description: `File name contains suspicious keyword: ${name}`,
        severity: 'medium',
        confidence: 0.6,
      });
      break;
    }
  }

  // Check for extremely small or large files
  if (fileSize < 100 && ext !== '.txt' && ext !== '.csv') {
    threats.push({
      type: 'suspicious',
      name: 'Tiny-File',
      description: `File is unusually small (${fileSize} bytes)`,
      severity: 'low',
      confidence: 0.5,
    });
  }

  return threats;
}

// Main malware scanning function
export async function scanFileForMalware(
  filePath: string,
  fileName: string,
  mimeType: string
): Promise<MalwareScanResult> {
  const startTime = Date.now();
  const threats: MalwareThreat[] = [];
  const warnings: string[] = [];

  try {
    // Read file
    const buffer = await fs.readFile(filePath);
    const fileHash = crypto.createHash('sha256').update(buffer).digest('hex');

    // 1. Scan for known signatures
    const signatureThreats = scanForSignatures(buffer);
    threats.push(...signatureThreats);

    // 2. Analyze file entropy
    const entropyThreats = analyzeFileEntropy(buffer);
    threats.push(...entropyThreats);

    // 3. Scan file metadata
    const metadataThreats = scanFileMetadata(fileName, buffer.length);
    threats.push(...metadataThreats);

    // 4. Scan text content for suspicious patterns
    if (mimeType.startsWith('text/') || mimeType === 'application/json') {
      try {
        const content = buffer.toString('utf-8');
        const stringThreats = scanForSuspiciousStrings(content);
        threats.push(...stringThreats);
      } catch (error) {
        warnings.push('Failed to analyze text content');
      }
    }

    // 5. Special checks for HTML files
    if (mimeType === 'text/html') {
      try {
        const content = buffer.toString('utf-8');

        // Check for script tags
        if (/<script[^>]*>.*?<\/script>/gi.test(content)) {
          threats.push({
            type: 'suspicious',
            name: 'HTML-Script',
            description: 'HTML file contains script tags',
            severity: 'medium',
            confidence: 0.8,
          });
        }

        // Check for iframe tags
        if (/<iframe[^>]*>/gi.test(content)) {
          threats.push({
            type: 'suspicious',
            name: 'HTML-Iframe',
            description: 'HTML file contains iframe tags',
            severity: 'medium',
            confidence: 0.7,
          });
        }
      } catch (error) {
        warnings.push('Failed to analyze HTML content');
      }
    }

    // 6. Special checks for archive files
    if (['application/zip', 'application/x-rar-compressed', 'application/x-7z-compressed'].includes(mimeType)) {
      warnings.push('Archive files should be extracted and scanned separately');

      // For now, just check if archive is very large (potential ZIP bomb)
      if (buffer.length > 100 * 1024 * 1024) { // 100MB
        threats.push({
          type: 'suspicious',
          name: 'Large-Archive',
          description: 'Large archive file detected - potential ZIP bomb',
          severity: 'medium',
          confidence: 0.6,
        });
      }
    }

    // Calculate overall confidence and determine if file is clean
    const maxConfidence = Math.max(...threats.map(t => t.confidence), 0);
    const criticalThreats = threats.filter(t => t.severity === 'critical');
    const highThreats = threats.filter(t => t.severity === 'high');

    const isClean = criticalThreats.length === 0 && highThreats.length === 0;

    return {
      isClean,
      threats,
      scanTime: Date.now() - startTime,
      confidence: isClean ? 1 - maxConfidence : maxConfidence,
      warnings,
      metadata: {
        fileSize: buffer.length,
        fileHash,
        scannedAt: new Date().toISOString(),
        scannerVersion: '1.0.0',
      },
    };

  } catch (error) {
    console.error('Error scanning file for malware:', error);

    return {
      isClean: false,
      threats: [{
        type: 'suspicious',
        name: 'Scan-Error',
        description: 'Failed to scan file completely',
        severity: 'medium',
        confidence: 0.5,
      }],
      scanTime: Date.now() - startTime,
      confidence: 0,
      warnings: [`Scan error: ${error instanceof Error ? error.message : 'Unknown error'}`],
      metadata: {
        fileSize: 0,
        fileHash: '',
        scannedAt: new Date().toISOString(),
        scannerVersion: '1.0.0',
      },
    };
  }
}

// Quick scan using only signature detection (faster but less thorough)
export async function quickMalwareScan(filePath: string): Promise<{ isClean: boolean; threats: MalwareThreat[] }> {
  try {
    const buffer = await fs.readFile(filePath);
    const threats = scanForSignatures(buffer);

    return {
      isClean: threats.length === 0,
      threats,
    };
  } catch (error) {
    console.error('Error during quick malware scan:', error);
    return {
      isClean: false,
      threats: [{
        type: 'suspicious',
        name: 'Quick-Scan-Error',
        description: 'Failed to perform quick scan',
        severity: 'medium',
        confidence: 0.5,
      }],
    };
  }
}

// Integration with external antivirus (placeholder for future implementation)
export async function scanWithExternalAntivirus(
  filePath: string,
  scannerType: 'clamav' | 'windows-defender' | 'custom' = 'clamav'
): Promise<MalwareScanResult> {
  // This is a placeholder for integration with real antivirus engines
  // In production, you would integrate with:
  // - ClamAV (open source)
  // - Windows Defender API
  // - Commercial antivirus APIs

  const warnings: string[] = [`External antivirus scanning (${scannerType}) not implemented - using internal scanner only`];

  // For now, fall back to internal scanner
  return scanFileForMalware(filePath, path.basename(filePath), 'application/octet-stream');
}